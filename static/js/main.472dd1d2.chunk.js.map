{"version":3,"sources":["requestAPI.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["promiseApiRequest","url","Promise","resolve","reject","xhr","XMLHttpRequest","onreadystatechange","readyState","DONE","status","JSON","parse","responseText","open","send","iterableApiRequest","stackingData","console","log","then","response","newData","hasOwnProperty","length","data","push","slice","indexOf","cursor","initialApiRequest","initialUrl","newUrl","processDataAsync","rawRewardArray","uniqueGatewayHashes","returnValue","Map","all","map","v","i","a","values","forEach","set","address","name","replace","getGateways","reduce","c","gateway","gatewayLookup","item","index","amount","timestamp","minerHash","minerName","get","block","id","columns","field","headerName","width","App","React","useState","hotspotAddress","onChangeHotspotAddress","ownerAddress","onChangeOwnerAddress","startDate","onChangeStartDate","endDate","onChangeEndDate","pullingData","onChangePullingData","rows","onChangeRows","source","onChangeSource","useSearchParams","searchParams","useEffect","hs","ow","start","possibleStartDate","moment","utc","isValid","end","possibleEndDate","className","rel","href","Container","sx","height","marginBottom","LocalizationProvider","dateAdapter","DateAdapter","Box","my","mb","ToggleButtonGroup","value","exclusive","color","fullWidth","onChange","event","newSource","aria-label","ToggleButton","TextField","maxRows","style","label","variant","target","DateTimePicker","inputFormat","newValue","renderInput","params","minDate","clearable","mt","Button","size","onClick","startTime","endTime","formatedStartTime","toISOString","formatedEndTime","d","getHotspotsRewards","finally","getOwnerRewards","disabled","maxHeight","components","Toolbar","justifyContent","display","csvOptions","allColumns","fileName","format","printOptions","disableToolbarButton","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","basename","process","path","element","document","getElementById"],"mappings":"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","file":"static/js/main.472dd1d2.chunk.js","sourcesContent":["// @ts-nocheck\n// disable typescript checking for development\n\nimport moment, { Moment } from 'moment'\n\n// taken from https://github.com/jstnryan/helium-reward-log/blob/master/js/index.js\n\nexport type RewardEntry = {\n    timestamp: string,\n    minerHash: string,\n    minerName: string,\n    block: number,\n    amount: number,\n    id: number,\n}\n\nexport type ServerRewardResponse = {\n    account: string,\n    amount: number,\n    block: number,\n    gateway: string,\n    hash: string,\n    timestamp: string,\n}\n\nexport type ServerMinerResponse = {\n    address: string,\n    name: string,\n    block: number,\n    block_added: number,\n    elevation: number,\n    gain: number,\n    geocode: {\n        city_id: string\n        long_city: string\n        long_country: string,\n        long_state: string,\n        long_street: string,\n        short_city: string\n        short_country: string,\n        short_state: string,\n        short_street: string,\n    }\n    last_change_block: number,\n    last_poc_challenge: number,\n    lat: number,\n    lng: number,\n    location: string,\n    location_hex: string,\n    mode: string,\n    nonce: number,\n    owner: string,\n    payer: string,\n    reward_scale: number,\n    speculative_nonce: number,\n    status: {\n        timestamp: string,\n        online: string,\n        listen_addrs: Array<string>,\n        height: number\n    }\n    timestamp_added: string\n}\n\nexport type ServerResponse = {\n    data: Array<ServerRewardResponse>,\n    // data: Array<ServerRewardResponse> | Array<ServerMinerResponse>,\n    cursor?: string\n}\n\nexport function promiseApiRequest(url:string):Promise<ServerResponse> {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState === XMLHttpRequest.DONE) {\n                if (xhr.status === 200) {\n                    resolve(JSON.parse(xhr.responseText))\n                } else {\n                    reject('server rejected request')\n                }\n            }\n        }\n        xhr.open(\"GET\", url);\n        xhr.send();\n    })\n}\n\nexport function iterableApiRequest(url:string, stackingData:Array<ServerRewardResponse>):Promise<Array<ServerRewardResponse>> {\n    console.log('calling iterable request')\n    return promiseApiRequest(url).then((response) => {\n        const newData = stackingData;\n        if(response.hasOwnProperty('data')){\n            console.log('adding more entries', stackingData.length, response.data.length)\n            newData.push(...response.data)\n        }\n        if (response.hasOwnProperty('cursor')) {\n                const newUrl = url.slice(0, url.indexOf('&cursor=')) + '&cursor=' + response.cursor\n                // loop over cursors\n                return iterableApiRequest(newUrl, newData)\n            } else {\n                // exit condition\n                return newData\n            }\n\n        })\n}\n\n// iterable promises source: https://cmichel.io/dynamically-chaining-promises\nexport function initialApiRequest(initialUrl:string):Promise<Array<ServerRewardResponse>> {\n    return new Promise((resolve, reject) => {\n        promiseApiRequest(initialUrl).then((response) => {\n            if (response.hasOwnProperty('cursor')) {\n                const newUrl = initialUrl.slice(0, initialUrl.indexOf('&cursor=')) + '&cursor=' + response.cursor\n                // loop over cursors\n                resolve(iterableApiRequest(newUrl, response.data))\n            } else {\n                // end condition\n                resolve(response.data)\n            }\n\n        })\n    })\n}\n\n\nexport function getOwnerRewards(ownerAddress:string, startTime:Moment, endTime:Moment):Promise<Array<RewardEntry>> {\n    // error within the api requiring a negative UTC offset => no offset\n    const formatedStartTime = startTime.toISOString(false)\n    const formatedEndTime = endTime.toISOString(false)\n    // console.log(\"getting rewards for\", ownerAddress, formatedStartTime, formatedEndTime)    \n\n    let url = 'https://api.helium.io/v1/accounts/' + ownerAddress + '/rewards?max_time=' + formatedEndTime + '&min_time=' + formatedStartTime;\n\n    return initialApiRequest(url).then((data) => {\n        return processDataAsync(data).then((d) => {\n            return d\n        })\n    })\n}\n\nexport function getHotspotsRewards(hotspotAddress:string, startTime:Moment, endTime:Moment):Promise<Array<RewardEntry>> {\n    // error within the api requiring a negative UTC offset => no offset\n    const formatedStartTime = startTime.toISOString(false)\n    const formatedEndTime = endTime.toISOString(false)\n    console.log(\"getting rewards for\", hotspotAddress, formatedStartTime, formatedEndTime)    \n\n\n    let url = 'https://api.helium.io/v1/hotspots/' + hotspotAddress + '/rewards?max_time=' + formatedEndTime + '&min_time=' + formatedStartTime;\n    \n    return initialApiRequest(url).then((data) => {\n        return processDataAsync(data).then((d) => {\n            return d\n        })\n    })\n}\n\nfunction  getGateways(uniqueGatewayHashes:Array<string>):Promise<Map<string, string>> {\n    let returnValue:Map<string, string> = new Map()\n    return Promise.all(\n            // request all hotspot names\n            uniqueGatewayHashes.map((v, i, a) => {\n                return initialApiRequest('https://api.helium.io/v1/hotspots/' + v)\n            })\n        ).then((values) => {\n            console.log(values)\n            // create map of hotspot hash & name\n            values.forEach((v, i, a) => {\n                returnValue.set(v.address, v.name.replace(/-/g, ' '))\n            })\n        }).then(() => {\n            return returnValue\n        })\n}\n\nfunction processDataAsync(rawRewardArray:Array<ServerRewardResponse>):Promise<Array<RewardEntry>> {\n    const uniqueGatewayHashes:Array<string> = [...rawRewardArray.reduce((a,c)=>{\n        a.set(c.gateway, c.gateway);\n        return a;\n    }, new Map()).values()]\n    return getGateways(uniqueGatewayHashes).then((gatewayLookup) => {\n        return rawRewardArray.map((item, index) => {\n            let amount = item.amount / 100000000; // \"bones\" per HNT\n            let rObj:RewardEntry = {\n                timestamp: item.timestamp,\n                minerHash: item.gateway,\n                minerName: gatewayLookup.get(item.gateway),\n                block: item.block,\n                amount: amount,\n                id: index\n            }\n            return rObj\n        })\n    })\n}","import React from 'react';\nimport logo from './logo.svg';\nimport Container from '@mui/material/Container';\nimport Typography from '@mui/material/Typography';\nimport Box from '@mui/material/Box';\nimport Link from '@mui/material/Link';\nimport { Button, TextField, ToggleButton, ToggleButtonGroup, Fab } from '@mui/material';\nimport DateAdapter from '@mui/lab/AdapterMoment';\nimport moment, { Moment } from 'moment'\nimport { LocalizationProvider } from '@mui/lab';\nimport { DateTimePicker } from '@mui/lab';\nimport './App.css';\nimport { getOwnerRewards, getHotspotsRewards } from './requestAPI';\nimport { DataGrid, GridRowsProp, GridColDef, GridToolbarExport, GridToolbarContainer } from '@mui/x-data-grid';\nimport { RewardEntry } from './requestAPI';\nimport { useSearchParams } from 'react-router-dom'\n\nconst columns: GridColDef[] = [\n  { field: 'timestamp', headerName: 'Time stamp (UTC)', width: 150 },\n  { field: 'minerHash', headerName: 'Miner Hash', width: 150 },\n  { field: 'minerName', headerName: 'Miner Name', width: 150 },\n  { field: 'block', headerName: 'Block Number', width: 150 },\n  { field: 'amount', headerName: 'Amount', width: 150 },\n];\n\nconst formats = {\n  monthAndYear: \"yyyy MM\",\n};\n\nfunction App() {\n\n  const [hotspotAddress, onChangeHotspotAddress] = React.useState<string>('');\n  const [ownerAddress, onChangeOwnerAddress] = React.useState<string>('');\n  const [startDate, onChangeStartDate] = React.useState<Moment | null>(null);\n  const [endDate, onChangeEndDate] = React.useState<Moment | null>(null);\n  const [pullingData, onChangePullingData] = React.useState<boolean>(false);\n  const [rows, onChangeRows] = React.useState<Array<RewardEntry>>([])\n  const [source, onChangeSource] = React.useState<string>('hotspot')\n  const [searchParams] = useSearchParams()\n\n  React.useEffect(()=>{\n    const hs = searchParams.get(\"hs\")\n    if(hs !== null) onChangeHotspotAddress(hs)\n\n    const ow = searchParams.get(\"ow\")\n    if(ow !== null) onChangeOwnerAddress(ow)\n\n    // change to owner mode if owner hash was present but no hotspot\n    if(hs === null && ow !== null) onChangeSource(\"owner\")\n\n    const start = searchParams.get(\"start\")\n    if(start !== null){\n      let possibleStartDate = moment.utc(start, 'YYYYMMDDTHH:mm:ss')\n      if( possibleStartDate.isValid() ) onChangeStartDate(possibleStartDate)\n    }\n\n    const end = searchParams.get(\"end\")\n    if(end !== null){\n      const possibleEndDate = moment.utc(end, 'YYYYMMDDTHH:mm:ss')\n      if( possibleEndDate.isValid() ) onChangeEndDate(possibleEndDate)\n    }\n\n  }, [searchParams])\n\n\n  function CustomToolbar() {\n    return (\n      <GridToolbarContainer style={{\n        justifyContent: 'center',\n        display: rows.length > 0  ? 'block' : 'none',\n        }}>\n        <GridToolbarExport\n          csvOptions={{\n            allColumns: true,\n            fileName:\n              startDate !== null && endDate !== null ? 'heliumExport_'+source+'_'+startDate.format(\"YYYYMMDD-HH mm\")+'_'+endDate.format(\"YYYYMMDD-HHmm\")+'.csv' :\n              'heliumExport.csv',\n          }}\n          printOptions={{\n            disableToolbarButton: true\n          }}\n        />\n      </GridToolbarContainer>\n    );\n  }\n\n\n  return (\n    <div className=\"App\">\n      <link\n        rel=\"stylesheet\"\n        href=\"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap\"\n      />\n      <Container sx={{height: \"70vh\", marginBottom: 50} }>\n      <LocalizationProvider dateAdapter={DateAdapter} >\n      <Box\n        my={2}\n      >\n        <Box\n          mb={1}\n        >\n          <ToggleButtonGroup\n            value={source}\n            exclusive\n            color=\"primary\"\n            fullWidth={true}\n            onChange={(event, newSource) => {\n              if (newSource !== null) {\n                onChangeSource(newSource)\n              }\n            }}\n            aria-label=\"Choose between hotspot or owner as data source\"\n          >\n            <ToggleButton value=\"hotspot\" aria-label=\"hotspot\">\n              Hotspot\n            </ToggleButton>\n            <ToggleButton value=\"owner\" aria-label=\"owner\">\n              Owner\n            </ToggleButton>\n          </ToggleButtonGroup>\n        </Box>\n\n        {\n          source === \"hotspot\" ?\n          <TextField \n          value={hotspotAddress}\n          maxRows={1}\n          style={{\n            width: 500\n          }}\n          id=\"hotspot_address\"\n          label=\"Hotspot address\"\n          variant=\"outlined\"\n          onChange={(event) => {\n            onChangeHotspotAddress(event.target.value)\n          }}\n          />\n          :\n        <TextField \n          value={ownerAddress}\n          maxRows={1}\n          style={{\n            width: 500\n          }}\n          id=\"owner_address\"\n          label=\"Owner address\"\n          variant=\"outlined\"\n          onChange={(event) => {\n            onChangeOwnerAddress(event.target.value)\n          }}\n          />}\n      </Box>\n      <Box my={2}>\n        <DateTimePicker\n          label=\"Start Date (UTC)\"\n          value={startDate}\n          inputFormat={\"YYYY/MM/DD HH:mm:ss\"}\n          onChange={(newValue) => {\n            console.log(newValue)\n            if(newValue !== null) onChangeStartDate(newValue);\n          }}\n          renderInput={(params) => <TextField {...params} style={{width: 500}} />}\n          />\n      </Box>\n      <Box my={2}>\n        <DateTimePicker\n          label=\"End Date (UTC)\"\n          value={endDate}\n          minDate={startDate}\n          inputFormat={\"YYYY/MM/DD HH:mm:ss\"}\n          clearable={true}\n          onChange={(newValue) => {\n            if(newValue !== null) onChangeEndDate(newValue);\n          }}\n          renderInput={(params) => <TextField {...params} style={{width: 500}}  />}\n          />\n      </Box>\n\n      <Box\n        mt={2}\n        mb={4}\n      >\n\n      <Button\n        variant=\"contained\"\n        size={'large'}\n        onClick={(event) => {\n          console.log(\"clicked button\")\n          if(startDate !== null && endDate !== null){\n            if(source === \"hotspot\"){\n              onChangePullingData(true)\n              onChangeRows([])\n              getHotspotsRewards(hotspotAddress, startDate, endDate).then((data) => {\n                onChangeRows(data)\n              }).finally(() => {\n                onChangePullingData(false)\n              })\n            } else if(source === \"owner\"){\n              onChangePullingData(true)\n              onChangeRows([])\n              getOwnerRewards(ownerAddress, startDate, endDate).then((data) => {\n                onChangeRows(data)\n              }).finally(() => {\n                onChangePullingData(false)\n              })\n            }\n          }\n        }}\n        disabled={startDate === null || endDate === null}\n        >{pullingData ? 'Pulling data' :  \"Fetch rewards\"}</Button>\n      </Box>\n\n      <DataGrid\n        rows={rows}\n        columns={columns}\n        style={{maxHeight: \"100vh\", marginBottom: 16,}}\n        components={{\n          Toolbar: CustomToolbar,\n        }}\n      />\n\n      {/* \n      // Additional download only available on the MUI pro (paid) license\n      <Fab\n        variant=\"extended\"\n        size={'large'}\n        onClick={(event) => {}}\n        sx={{marginBottom: 2}}\n        disabled={rows.length === 0}\n      >\n        Download data\n      </Fab> */}\n      \n      \n      </LocalizationProvider>\n    </Container>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter\n      basename={`/${process.env.PUBLIC_URL}`}\n    >\n      <Routes>\n        <Route path=\"\" element={<App />}/>\n      </Routes>\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}